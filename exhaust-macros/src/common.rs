use proc_macro2::{Ident, Span, TokenStream as TokenStream2};
use quote::{quote, ToTokens as _};
use syn::parse_quote;
use syn::punctuated::Punctuated;

/// Pick a name for a type generated by this macro.
/// Such names can conflict with the macro caller’s own types, so we want them to be named in
/// a predictable fashion.
///
/// `input_type_name` is the name of the type our derive macro was applied to.
/// `role_name` is a camel-case component describing this type in particular, e.g. “Iter”.
///
/// This function is also available as a method on `ExhaustContext`.
pub fn generated_type_name(input_type_name: &str, role_name: &str) -> Ident {
    Ident::new(
        &format!("Exhaust{input_type_name}{role_name}"),
        Span::mixed_site(),
    )
}

/// Data and helpers for generating an exhaustive iterator, that are common
/// between the enum and struct versions.
pub(crate) struct ExhaustContext {
    /// Maximum visibility for the generated types, inherited from the declaration
    /// (e.g. `pub Foo` should have a `pub ExhaustFoo` iterator).
    pub vis: syn::Visibility,

    /// Generics present on the declaration, which need to be copied to the
    /// iterator.
    pub generics: syn::Generics,

    /// Name of the type being exhausted, which is also the type the macro is applied to.
    pub item_type: ConstructorSyntax,

    /// Name of the generated factory type, which is a unit struct containing a struct
    /// like the type being exhausted but with different field types,
    /// and is the item type of the generated iterator.
    pub factory_type: FactoryType,

    /// Name of the generated iterator type.
    pub iterator_type_name: Ident,

    /// Path by which the `exhaust` crate should be referred to.
    pub exhaust_crate_path: syn::Path,
}

/// Information about the `Exhaust::Factory` associated type used by the `Exhaust` implementation
/// we are generating.
pub(crate) enum FactoryType {
    /// `#[exhaust(factory_is_self)]` mode. No factory type is generated; the `Exhaust` implementor
    /// is also the factory.
    IsSelf,

    /// An opaque factory type with the given name is generated.
    Separate(ConstructorSyntax),
}

impl ExhaustContext {
    pub fn helpers(&self) -> syn::Path {
        let mut path = self.exhaust_crate_path.clone();
        path.segments.push(parse_quote! { mh_ });
        path
    }

    /// Pick a name for a type generated by this macro.
    /// Such names can conflict with the macro caller’s own types, so we want them to be named in
    /// a predictable fashion.
    ///
    /// `input_type_name` is the name of the type our derive macro was applied to.
    /// `role_name` is a camel-case component describing this type in particular, e.g. “Iter”.
    ///
    /// This method is also available as a free function to work without a context.
    pub fn generated_type_name(&self, role_name: &str) -> Result<Ident, syn::Error> {
        Ok(generated_type_name(
            &self.item_type.name_for_incorporation()?,
            role_name,
        ))
    }

    /// Generate the TraitBound containing the `exhaust::Exhaust` trait.
    fn exhaust_trait_bound(&self) -> syn::TraitBound {
        let mut path;
        if self.factory_is_self() {
            path = self.helpers();
            path.segments
                .push(parse_quote! { ExhaustWithFactoryEqSelf });
        } else {
            path = self.exhaust_crate_path.clone();
            path.segments.push(parse_quote! { Exhaust });
        }
        syn::TraitBound {
            paren_token: None,
            modifier: syn::TraitBoundModifier::None,
            lifetimes: None,
            path,
        }
    }

    /// As [`syn::Generics::split_for_impl`], but adding the `::exhaust::Exhaust` bound.
    ///
    /// TODO: this used to take arguments for extra bounds, but now that it doesn't,
    /// maybe the results of this should be precomputed and stored in `ExhaustContext`.
    pub fn generics_with_bounds(
        &self,
    ) -> (
        syn::ImplGenerics<'_>,
        syn::TypeGenerics<'_>,
        Punctuated<syn::WherePredicate, syn::token::Comma>,
    ) {
        let bounds =
            Punctuated::from_iter([syn::TypeParamBound::Trait(self.exhaust_trait_bound())]);
        let generics = &self.generics;
        let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
        let mut augmented_where_predicates = match where_clause {
            Some(clause) => clause.predicates.clone(),
            None => Punctuated::new(),
        };
        for g in generics.params.iter() {
            if let syn::GenericParam::Type(g) = g {
                augmented_where_predicates.push(syn::WherePredicate::Type(syn::PredicateType {
                    lifetimes: None,
                    bounded_ty: syn::Type::Verbatim(g.ident.to_token_stream()),
                    colon_token: <_>::default(),
                    bounds: bounds.clone(),
                }));
            }
        }
        (impl_generics, ty_generics, augmented_where_predicates)
    }

    pub fn iterator_doc(&self) -> String {
        match &self.item_type {
            // TODO: No tests to validate this doc link
            ConstructorSyntax::Braced(name) => format!(
                "Iterator over all values of [`{name}`].\n\
                \n\
                To obtain an instance of this iterator, call [`Exhaust::exhaust()`].\n\
                \n\
                [`Exhaust::exhaust()`]: {crate}::Exhaust",
                crate = self.exhaust_crate_path.to_token_stream(),
            ),
            ConstructorSyntax::Tuple => {
                format!(
                    "Iterator over all tuples of {len} elements.\n\
                    \n\
                    To obtain an instance of this iterator, call [`Exhaust::exhaust()`].",
                    len = self.generics.params.len(),
                )
            }
        }
    }

    /// Generate the parts of the trait implementations for the iterator and factory
    /// that do not depend on whether the type being exhausted is an enum or struct.
    pub fn impl_iterator_and_factory_traits(
        &self,
        iterator_next_body: TokenStream2,
        iterator_default_body: TokenStream2,
        iterator_clone_body: TokenStream2,
    ) -> TokenStream2 {
        let exhaust_crate_path = &self.exhaust_crate_path;
        let helpers = self.helpers();
        let iterator_type_name = &self.iterator_type_name;
        let (impl_generics, ty_generics, augmented_where_predicates) = self.generics_with_bounds();
        let item_type_inst = self.item_type.parameterized(&self.generics);

        let factory_impls = match &self.factory_type {
            // Don't try to implement for an existing type
            // (that might be either () or the Self type).
            FactoryType::Separate(ConstructorSyntax::Tuple) | FactoryType::IsSelf => quote! {},

            FactoryType::Separate(ConstructorSyntax::Braced(factory_outer_type_name)) => quote! {
                impl #impl_generics #helpers::fmt::Debug for #factory_outer_type_name #ty_generics
                where #augmented_where_predicates {
                    fn fmt(&self, f: &mut #helpers::fmt::Formatter<'_>) -> #helpers::fmt::Result {
                        // TODO: Print the contents of the factory.
                        // We know this is possible because the `Exhaust` trait requires
                        // `Self::Factory: Debug`.
                        //
                        // Ideally we would just print `T::from_factory(self)`, but we don't know
                        // whether that implements `Debug` or not.
                        // (But a macro helper attribute could let the user tell us that.)
                        f.debug_struct(stringify!(#factory_outer_type_name))
                            .finish_non_exhaustive()
                    }
                }
            },
        };

        quote! {
            impl #impl_generics #helpers::Iterator for #iterator_type_name #ty_generics
            where #augmented_where_predicates {
                type Item = <#item_type_inst as #exhaust_crate_path::Exhaust>::Factory;

                fn next(&mut self) -> #helpers::Option<Self::Item> {
                    #![allow(unreachable_code)] // an iterator or factory might be uninhabited
                    #iterator_next_body
                }
            }

            impl #impl_generics #helpers::FusedIterator for #iterator_type_name #ty_generics
            where #augmented_where_predicates {}

            impl #impl_generics #helpers::Default for #iterator_type_name #ty_generics
            where #augmented_where_predicates {
                fn default() -> Self {
                    #iterator_default_body
                }
            }

            // A manual impl of Debug is required to provide the right bounds on the generics.
            impl #impl_generics #helpers::fmt::Debug for #iterator_type_name #ty_generics
            where #augmented_where_predicates {
                fn fmt(&self, f: &mut #helpers::fmt::Formatter<'_>) -> #helpers::fmt::Result {
                    // TODO: Print the current enum state.
                    // We know this is possible because the `Exhaust` trait requires
                    // `Self::Iter: Debug`.
                    f.debug_struct(stringify!(#iterator_type_name))
                        .finish_non_exhaustive()
                }
            }

            // A manual impl of Clone is required to *not* have a `Clone` bound on the generics.
            impl #impl_generics #helpers::Clone for #iterator_type_name #ty_generics
            where #augmented_where_predicates {
                fn clone(&self) -> Self {
                    #iterator_clone_body
                }
            }

            #factory_impls
        }
    }

    pub fn factory_is_self(&self) -> bool {
        matches!(self.factory_type, FactoryType::IsSelf)
    }

    /// Returns the path, without generics, of the factory type.
    /// This may be used when constructing values of the factory type,
    /// or have generics appended to make the full name of the type.
    pub fn factory_type_path(&self) -> Result<&TokenStream2, syn::Error> {
        match self.factory_type {
            FactoryType::IsSelf => self.item_type.path(),
            FactoryType::Separate(ref cs) => cs.path(),
        }
    }
}

/// How to name a type for construction.
#[derive(Clone)]
pub(crate) enum ConstructorSyntax {
    /// A struct or variant name to used with `MyStruct { field: value }` syntax.
    /// This may be a single identifier or a path to a variant.
    Braced(TokenStream2),
    /// The type is a primitive tuple.
    Tuple,
}

impl ConstructorSyntax {
    /// Name to use for concatenation to construct new type names.
    pub fn name_for_incorporation(&self) -> Result<String, syn::Error> {
        match self {
            ConstructorSyntax::Braced(name) => Ok(name.to_string()),
            // we could return “Tuple” here if it ever became needed.
            ConstructorSyntax::Tuple => Err(syn::Error::new(
                Span::call_site(),
                "exhaust-macros internal error: no name for tuple types",
            )),
        }
    }

    /// Returns the path for use in a type declaration or pattern.
    pub(crate) fn path(&self) -> Result<&TokenStream2, syn::Error> {
        match self {
            ConstructorSyntax::Braced(name) => Ok(name),
            ConstructorSyntax::Tuple => Err(syn::Error::new(
                Span::call_site(),
                "exhaust-macros internal error: no name for tuple types",
            )),
        }
    }

    /// Type applied to given type parameters.
    pub(crate) fn parameterized(&self, generics: &syn::Generics) -> TokenStream2 {
        match self {
            ConstructorSyntax::Braced(name) => {
                let (_, ty_generics, _) = generics.split_for_impl();
                quote! { #name #ty_generics }
            }
            ConstructorSyntax::Tuple => {
                let par = generics.type_params();
                quote! { ( #( #par , )* ) }
            }
        }
    }

    /// Constructor applied to fields.
    /// The fields MUST be in original declardd order, to handle the tuple case.
    pub(crate) fn value_expr<'a>(
        &self,
        names: impl Iterator<Item = &'a TokenStream2>,
        values: impl Iterator<Item = &'a TokenStream2>,
    ) -> TokenStream2 {
        match self {
            ConstructorSyntax::Braced(name) => {
                quote! { #name { #( #names : #values , )* } }
            }
            ConstructorSyntax::Tuple => {
                quote! { ( #( #values , )* ) }
            }
        }
    }

    /// Given an enum type name, produce a variant constructor.
    pub(crate) fn with_variant(&self, target_variant_ident: &Ident) -> ConstructorSyntax {
        match self {
            ConstructorSyntax::Braced(name) => {
                let mut name = name.clone();
                name.extend(quote! { :: });
                name.extend(target_variant_ident.to_token_stream());
                ConstructorSyntax::Braced(name)
            }
            ConstructorSyntax::Tuple => panic!("a tuple is not an enum"),
        }
    }
}

/// Generate arms for a match which maps every field of every variant of an enum.
pub(crate) fn clone_like_match_arms(
    variants: &Punctuated<syn::Variant, syn::Token![,]>,
    input_type_name: &TokenStream2,
    output_type_name: &TokenStream2,
    binding_mode: &TokenStream2,
    value_transform: impl Fn(TokenStream2) -> TokenStream2,
) -> Vec<TokenStream2> {
    variants
        .iter()
        .map(|target_variant| {
            let variant_name = &target_variant.ident;
            match &target_variant.fields {
                syn::Fields::Named(_) => {
                    let members = target_variant.fields.members().collect::<Vec<_>>();
                    let values = members
                        .iter()
                        .map(|member| value_transform(member.to_token_stream()))
                        .collect::<Vec<_>>();
                    quote! {
                        #input_type_name::#variant_name {
                            #( #binding_mode #members, )*
                        } => #output_type_name::#variant_name {
                            #( #members: #values, )*
                        }
                    }
                }
                syn::Fields::Unnamed(fields) => {
                    let vars: Vec<Ident> = (0..fields.unnamed.len())
                        .map(|i| Ident::new(&format!("clone_f{i}"), Span::mixed_site()))
                        .collect();
                    let values = vars
                        .iter()
                        .map(|var| value_transform(var.to_token_stream()))
                        .collect::<Vec<_>>();
                    quote! {
                        #input_type_name::#variant_name(
                            #( #binding_mode #vars, )*
                        ) => #output_type_name::#variant_name(
                            #( #values, )*
                        )
                    }
                }
                syn::Fields::Unit => quote! {
                    #input_type_name::#variant_name => #output_type_name::#variant_name
                },
            }
        })
        .collect()
}

/// Generate a match arm which is a transformation which maps every field of the matched struct
/// to corresponding fields of another struct.
pub(crate) fn clone_like_struct_conversion(
    fields: &syn::Fields,
    input_type_name: &TokenStream2,
    output_type_name: &TokenStream2,
    // Binding mode to use with each field binding, e.g. the empty string, `ref`, or `ref mut`.
    binding_mode: &TokenStream2,
    // Function from struct field name to value expression for the output struct.
    value_transform: impl Fn(TokenStream2) -> TokenStream2,
) -> TokenStream2 {
    match fields {
        syn::Fields::Named(_) => {
            let members = fields.members().collect::<Vec<_>>();
            let values = members
                .iter()
                .map(|member| value_transform(member.to_token_stream()))
                .collect::<Vec<_>>();
            quote! {
                #input_type_name {
                    #( #binding_mode #members, )*
                } => #output_type_name {
                    #( #members: #values, )*
                }
            }
        }
        syn::Fields::Unnamed(fields) => {
            let vars: Vec<Ident> = (0..fields.unnamed.len())
                .map(|i| Ident::new(&format!("clone_f{i}"), Span::mixed_site()))
                .collect();
            let values = vars
                .iter()
                .map(|var| value_transform(var.to_token_stream()))
                .collect::<Vec<_>>();
            quote! {
                #input_type_name(
                    #( #binding_mode #vars, )*
                ) => #output_type_name(
                    #( #values, )*
                )
            }
        }
        syn::Fields::Unit => quote! {
            #input_type_name => #output_type_name
        },
    }
}
